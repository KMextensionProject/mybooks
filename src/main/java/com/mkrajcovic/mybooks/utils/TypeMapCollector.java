package com.mkrajcovic.mybooks.utils;

import java.util.Collections;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;

import com.mkrajcovic.mybooks.db.TypeMap;

/**
 * T – Type of elements in Stream. These are type of input parameters to the reduction operation.
 * A – Type of the mutable accumulator for the reduction operation
 * R – Type of the result. In simple word it is the type of the output generated by the reduction operation.
 * 
 * @author martin
 */
public class TypeMapCollector<T> implements Collector<T, TypeMap, TypeMap> {

	private Function<? super T, String> keyMapper;
	private Function<? super T, ?> valueMapper;

	private TypeMapCollector(Function<? super T, String> keyMapper, Function<? super T, ?> valueMapper) {
		this.keyMapper = keyMapper;
		this.valueMapper = valueMapper;
	}

	/**
	 * 
	 * @param <T> generic input
	 * @param keyMapper -> mapps input as key into a resulting TypeMap
	 * @param valueMapper -> mapps input as value into a resulting TypeMap
	 * @return
	 */
	public static <T> TypeMapCollector<T> toTypeMap(Function<? super T, String> keyMapper, Function<? super T, ?> valueMapper) {
		return new TypeMapCollector<T>(keyMapper, valueMapper);
	}

	/**
	 * It is the first step in the flow of elements collection process. 
	 * In this process a container is created to hold the elements from the 
	 * Stream.
	 * 
	 * Return type of this method is the Supplier of the container type. 
	 * We need to return a Supplier function that supplies a container to 
	 * hold Stream elements. 
	 */
	@Override
	public Supplier<TypeMap> supplier() {
		return TypeMap::new;
	}

	/**
	 * In this step each element in the stream is added into the container 
	 * created in the Supply step.
	 * 
	 * In this method we have to return a BiConsumer function which accepts 
	 * the container, and a single element from the Stream. The consumer 
	 * defines the strategy, how the element should be added to the container.
	 */
	@Override
	public BiConsumer<TypeMap, T> accumulator() {
		return (map, entry) -> map.put(keyMapper.apply(entry), valueMapper.apply(entry));
	}

	/**
	 * This is an optional step, which is executed only if the stream is 
	 * processed in parallel environment. In parallel fashion stream elements 
	 * are divided and processed simultaneously, because of which there will 
	 * be multiple accumulators for the stream. Combine step is to combine all 
	 * the accumulated elements into a single container. As stated, if the 
	 * Stream is sequential this step will be skipped.
	 *  
	 * This method or step is invoked only if the stream elements are processed 
	 * in parallel. The combiner function is to combine results of different 
	 * parallel calculations. In this method we need to return a BinaryOperator 
	 * function that combines the two accumulated containers. 
	 */
	@Override
	public BinaryOperator<TypeMap> combiner() {
		return (map1, map2) -> {
			map1.putAll(map2);
			return map1;
		};
	}

	/**
	 * This is the last step in the collection process. It is executed when 
	 * all the elements in Stream are accumulated in the supplied container. 
	 * In the finish step we will transform the container into the defined 
	 * result type. 
	 * 
	 * Finisher is the last bit in the flow. In this method we can return a 
	 * function to transform the accumulated and combined container into the 
	 * final output.
	 */
	@Override
	public Function<TypeMap, TypeMap> finisher() {
		return map -> map;
	}

	/**
	 * This method is to specify characteristics of the Collector. We have to 
	 * return a Set of Characteristics enum values.
	 * 
	 * UNORDERED - If this characteristic is set, the collector won’t depend on 
	 * the order of the element in the Stream.
	 */
	@Override
	public Set<Characteristics> characteristics() {
//		return Set.of(Characteristics.UNORDERED);
		return Collections.emptySet();
	}
}